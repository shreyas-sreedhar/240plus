// Function to get the tweet input box
function getTweetBox() {
  let tweetBox = document.querySelector('[data-testid="tweetTextarea_0"]');
  if (!tweetBox) {
    tweetBox = document.querySelector(".public-DraftEditor-content");
  }
  if (!tweetBox) {
    tweetBox = document.querySelector('div[aria-label="Post text"][role="textbox"]');
  }
  return tweetBox;
}

// Function to inject the "Send as Image" button
function injectConvertButton() {
  const tablist = document.querySelector('div[data-testid="toolBar"]');
  if (tablist) {
    const convertButton = createConvertButton();
    tablist.appendChild(convertButton);
    convertButton.addEventListener("click", handleTextConversion);
  }
}

// Helper function to create the convert button
function createConvertButton() {
  const convertButton = document.createElement("button");
  convertButton.style.minWidth = "20px";
  convertButton.style.minHeight = "20px";
  convertButton.style.marginLeft = "8px";
  convertButton.style.borderRadius = "20px";
  convertButton.style.padding = "8px";
  convertButton.style.backgroundColor = "#1d9bf0";
  convertButton.style.border = "None";
  convertButton.style.marginTop = "6px";

  convertButton.setAttribute("role", "tab");
  convertButton.setAttribute("aria-selected", "false");
  convertButton.setAttribute("data-testid", "convertToImageButton");
  convertButton.style.cursor = "pointer";

  const buttonText = document.createElement("div");
  buttonText.innerText = "Send as Image";
  buttonText.style.fontFamily = "Helvetica sans-serif";
  convertButton.appendChild(buttonText);

  return convertButton;
}

// Function to check and inject the button periodically
function checkAndInjectButton() {
  if (!document.querySelector('[data-testid="convertToImageButton"]')) {
    injectConvertButton();
    console.log("Checked and injected button");
  }
}

// Check periodically
setInterval(checkAndInjectButton, 1000);

// Function to generate images
function generateImages(text, authorUsername) {
  const canvasSize = 900;
  const padding = 60;
  const picSize = 100;
  const maxWidth = canvasSize - padding * 2;

  const canvas = document.createElement("canvas");
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  const context = canvas.getContext("2d");

  // Determine font size based on text length
  let fontSize = text.length < 100 ? 48 : text.length < 200 ? 36 : 24;
  const lineHeight = fontSize * 1.5;
  const maxLinesPerImage = Math.floor((canvasSize - padding * 3 - 100) / lineHeight);

  const imageDataUrls = [];

  // Split text into lines that fit within the canvas width
  function getLines(text, fontSize) {
    context.font = `${fontSize}px Arial, sans-serif`;
    const words = text.split(" ");
    const lines = [];
    let currentLine = words[0];

    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const width = context.measureText(currentLine + " " + word).width;
      if (width < maxWidth) {
        currentLine += " " + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    lines.push(currentLine);
    return lines;
  }

  let allLines = getLines(`"${text}"`, fontSize);

  // Calculate total text height
  let totalTextHeight = allLines.reduce((acc, line) => acc + lineHeight, 0);
  let startY = (canvasSize - totalTextHeight) / 2;

  // Draw on canvas
  context.fillStyle = "#ffffff"; // White background
  context.fillRect(0, 0, canvasSize, canvasSize);

  context.font = `${fontSize}px Arial, sans-serif`;
  context.fillStyle = "#000000"; // Black text
  context.textBaseline = "top"; // Align text vertically to top

  allLines.forEach((line, index) => {
    let textWidth = context.measureText(line).width;
    let lineY = startY + index * lineHeight;
    let lineX = (canvasSize - textWidth) / 2;
    context.fillText(line, lineX, lineY);
  });

  // Draw author username in the middle
  const usernameFontSize = 20;
  context.font = `bold ${usernameFontSize}px Arial, sans-serif`;
  context.fillStyle = "#000000"; // Black text
  context.textAlign = "center";
  context.fillText(`~ @${authorUsername}`, canvasSize / 2, canvasSize - padding - picSize + 60);

  // Add image number if there are multiple images
  if (allLines.length > maxLinesPerImage) {
    const imageNumber = Math.floor(allLines.length / maxLinesPerImage) + 1;
    context.textAlign = "right";
    context.fillText(`${imageNumber}/${Math.ceil(allLines.length / maxLinesPerImage)}`, canvasSize - padding, canvasSize - padding);
    context.textAlign = "left";
  }

  // Add watermark with reduced opacity and smaller font
  const watermarkFontSize = 14;
  context.font = `${watermarkFontSize}px Arial, sans-serif`;
  context.fillStyle = "rgba(0, 0, 0, 0.1)"; // Very light opacity black
  context.textAlign = "right";
  context.fillText("Generated by @240Plus", canvasSize - padding, canvasSize - padding - 25);

  // Add image to array
  imageDataUrls.push(canvas.toDataURL("image/png"));

  return imageDataUrls;
}

// Function to handle text conversion
async function handleTextConversion() {
  console.log("Converting text to image...");

  const tweetBox = getTweetBox();
  if (!tweetBox) {
    console.error("Tweet box not found");
    return;
  }

  const textNodes = Array.from(tweetBox.querySelectorAll("*"))
    .filter(
      (el) =>
        el.childNodes.length === 1 &&
        el.childNodes[0].nodeType === Node.TEXT_NODE
    )
    .map((el) => el.textContent);

  const text = textNodes.join("");

  let authorUsername = "unknown";
  const usernameElement = document.querySelector(
    'a[data-testid="AppTabBar_Profile_Link"]'
  );
  if (usernameElement) {
    authorUsername = usernameElement.getAttribute("href");
    if (authorUsername.startsWith("/")) {
      authorUsername = authorUsername.substring(1);
    }
  }

  console.log(`Username: ${authorUsername}`);

  try {
    const imageDataUrls = generateImages(text, authorUsername);

    // Clear the text from the tweet box
    clearTweetBox(tweetBox);

    // Insert the image into the tweet compose area
    await insertImageIntoTweet(imageDataUrls[0]);

    console.log("Text converted to image and inserted into tweet");

  } catch (error) {
    console.error("Error during text conversion:", error);
  }
}

function clearTweetBox(tweetBox) {
  tweetBox.innerHTML = '';
}

async function insertImageIntoTweet(imageDataUrl) {
  try {
    // Find the file input element
    const fileInput = document.querySelector('input[type="file"][accept^="image/"]');
    if (!fileInput) {
      throw new Error("File input for image upload not found");
    }

    // Convert data URL to Blob
    const response = await fetch(imageDataUrl);
    const blob = await response.blob();

    // Create a File object from the Blob
    const file = new File([blob], "tweet_image.png", { type: "image/png" });

    // Create a FileList object (which is what a file input normally produces)
    const dt = new DataTransfer();
    dt.items.add(file);
    fileInput.files = dt.files;

    // Dispatch a change event to notify the application that a file has been selected
    const event = new Event('change', { bubbles: true });
    fileInput.dispatchEvent(event);

    console.log("Image inserted into tweet");
  } catch (error) {
    console.error("Error inserting image:", error);
  }
}

// Listen for messages from the background script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "convertToImage") {
    handleTextConversion()
      .then(() => {
        sendResponse({ status: "Conversion completed" });
      })
      .catch((error) => {
        console.error("Error during conversion:", error);
        sendResponse({ status: "Conversion failed", error: error.message });
      });
    return true; // Indicates that the response is sent asynchronously
  }
});

console.log("Twitter Text to Image Converter content script loaded");
